<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Live FX Cam</title>
<style>
  :root{ --glass:rgba(12,12,14,.6); --line:rgba(255,255,255,.08); --ink:#fff; --accent:#3aa3ff; }
  *{ box-sizing:border-box; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  html,body{ height:100%; background:#000; color:var(--ink); }
  body{ margin:0; overscroll-behavior:none; }
  #app{ position:fixed; inset:0; }
  #stage{ position:absolute; inset:0; }
  video,canvas{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; border:0; }
  #cam{ opacity:0 } /* draw via canvas only */

  /* Start button ‚Äî large, centered, always visible until camera running */
  #btnStart{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    z-index:10; width:220px; height:64px; border-radius:16px; font-size:17px; font-weight:800;
    background:linear-gradient(180deg,#38A0FF,#1573D9); color:#03101f; border:1px solid #2e89db;
    box-shadow:0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.25);
  }
  #btnStart.hidden{ display:none; }

  /* Tiny gear to toggle controls */
  .fab{ position:absolute; z-index:9; width:44px; height:44px; border-radius:50%; display:grid; place-items:center;
        background:var(--glass); border:1px solid var(--line); -webkit-backdrop-filter:blur(8px); backdrop-filter:blur(8px);}
  #btnTogglePanel{ right:14px; top:14px; font-size:18px; }

  /* Control panel (hidden by default) */
  #panel{ position:absolute; left:50%; transform:translateX(-50%); bottom:14px; z-index:8; display:none; }
  #panel.show{ display:block; }
  .panel-inner{ display:flex; gap:8px; padding:8px; border-radius:16px; background:var(--glass); border:1px solid var(--line); -webkit-backdrop-filter:blur(10px); backdrop-filter:blur(10px); }
  .group{ display:flex; align-items:center; gap:6px; }
  .group input[type=range]{ width:120px }
  .group input[type=color]{ width:30px; height:26px; border:0; background:transparent; padding:0 }
  .group select, .group button{ appearance:none; border:1px solid var(--line); background:rgba(20,20,24,.65); color:var(--ink); padding:6px 10px; border-radius:10px; }
  .group button.rec{ border-color:#f33; color:#f33; }

  /* Recording dot (no text) */
  #recDot{ position:absolute; right:18px; top:70px; width:10px; height:10px; border-radius:50%; background:#f33; box-shadow:0 0 12px #f33; display:none; z-index:9; }

  ::selection{ background:transparent }
</style>
</head>
<body>
<div id="app">
  <div id="stage">
    <video id="cam" playsinline autoplay muted></video>
    <canvas id="fxCanvas"></canvas>

    <!-- Big central camera button -->
    <button id="btnStart" aria-label="Enable Camera">Enable Camera</button>

    <!-- Minimal UI -->
    <button id="btnTogglePanel" class="fab" aria-label="Toggle Controls">‚öôÔ∏è</button>
    <div id="recDot"></div>

    <!-- Hidden controls (no instructions text) -->
    <div id="panel">
      <div class="panel-inner">
        <div class="group"><select id="fx" disabled>
          <option value="rain">Rain</option>
          <option value="snow">Snow</option>
          <option value="fire">Fire</option>
          <option value="wind">Wind</option>
          <option value="none">None</option>
        </select></div>
        <div class="group"><input id="intensity" type="range" min="0" max="100" value="60" disabled></div>
        <div class="group"><input id="speed" type="range" min="0" max="100" value="60" disabled></div>
        <div class="group"><input id="size" type="range" min="0" max="100" value="50" disabled></div>
        <div class="group"><input id="dir" type="range" min="0" max="360" value="100" disabled></div>
        <div class="group"><input id="tint" type="color" value="#7fc5ff" disabled></div>
        <div class="group"><input id="glow" type="checkbox" disabled title="Glow"></div>
        <div class="group"><input id="motionBlur" type="checkbox" checked disabled title="Motion blur"></div>
        <div class="group"><button id="btnShot" disabled>üì∏</button></div>
        <div class="group"><button id="btnRec" class="rec" disabled>‚óè</button></div>
        <div class="group"><button id="btnFlip" disabled>‚Ü∫</button></div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // Elements
  const video = document.getElementById('cam');
  const canvas = document.getElementById('fxCanvas');
  const ctx = canvas.getContext('2d', { alpha: true });

  const btnStart = document.getElementById('btnStart');
  const btnTogglePanel = document.getElementById('btnTogglePanel');
  const panel = document.getElementById('panel');
  const recDot = document.getElementById('recDot');

  const fxSel = document.getElementById('fx');
  const intensityEl = document.getElementById('intensity');
  const speedEl = document.getElementById('speed');
  const sizeEl = document.getElementById('size');
  const dirEl = document.getElementById('dir');
  const tintEl = document.getElementById('tint');
  const glowEl = document.getElementById('glow');
  const blurEl = document.getElementById('motionBlur');
  const btnShot = document.getElementById('btnShot');
  const btnRec = document.getElementById('btnRec');
  const btnFlip = document.getElementById('btnFlip');

  // State
  let running = false;
  let facing = 'environment';
  let stream = null;
  let particles = [];
  let effect = 'rain';
  let w = 0, h = 0;
  const dpr = Math.max(1, Math.min(2, devicePixelRatio || 1));

  // --- UI
  btnTogglePanel.addEventListener('click', () => panel.classList.toggle('show'));

  // Always-visible Start button until camera runs
  btnStart.addEventListener('click', startCamera, { passive:true });

  async function startCamera(){
    try{
      // keep the button visible until we know we have a stream
      const s = await navigator.mediaDevices.getUserMedia({
        video: { facingMode:{ ideal:facing }, width:{ ideal:1280 }, height:{ ideal:720 } },
        audio: false
      });
      stream = s;
      video.srcObject = stream;
      await video.play().catch(()=>{});
      // now hide the button
      btnStart.classList.add('hidden');

      [fxSel,intensityEl,speedEl,sizeEl,dirEl,tintEl,glowEl,blurEl,btnFlip,btnShot,btnRec].forEach(el=>el.disabled=false);
      running = true;
      initEffect(effect);
      resize();
      requestAnimationFrame(tick);
    }catch(e){
      console.error(e);
      // keep the button visible so the user can try again
      btnStart.classList.remove('hidden');
    }
  }

  function stopCamera(){
    if (!stream) return;
    stream.getTracks().forEach(t=>t.stop());
    stream = null; running = false;
    btnStart.classList.remove('hidden'); // show again if stopped
  }

  // Resize & draw cover
  function resize(){
    const rect = canvas.getBoundingClientRect();
    w = Math.floor(rect.width * dpr);
    h = Math.floor(rect.height * dpr);
    if (canvas.width !== w || canvas.height !== h){ canvas.width = w; canvas.height = h; }
  }
  addEventListener('resize', resize);
  new ResizeObserver(resize).observe(canvas);
  function drawVideoCover(ctx, video, w, h){
    const vw = video.videoWidth, vh = video.videoHeight;
    if (!vw || !vh) return;
    const scale = Math.max(w / vw, h / vh);
    const dw = Math.floor(vw * scale), dh = Math.floor(vh * scale);
    const dx = Math.floor((w - dw) / 2), dy = Math.floor((h - dh) / 2);
    ctx.drawImage(video, dx, dy, dw, dh);
  }

  // Controls
  btnFlip.addEventListener('click', async ()=>{ facing = (facing==='user')?'environment':'user'; await startCamera(); });
  btnShot.addEventListener('click', ()=>{
    try{
      const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
      const tctx = tmp.getContext('2d', {alpha:true}); tctx.drawImage(canvas, 0, 0);
      const url = tmp.toDataURL('image/png');
      const a = document.createElement('a'); a.href = url; a.download = `livefx_${Date.now()}.png`; a.click();
      setTimeout(()=>URL.revokeObjectURL && URL.revokeObjectURL(url), 60000);
    }catch(e){ console.error(e); }
  });

  // Recording (small red dot, no text)
  let mediaRecorder=null, chunks=[], recording=false, recordTimer=null;
  btnRec.addEventListener('click', ()=>{ if (!recording) startRecording(); else stopRecording(); });
  function pickBestMime(){
    const prefs = ['video/mp4;codecs=h264','video/mp4','video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm'];
    for (const m of prefs){ if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m)) return m; }
    return '';
  }
  function startRecording(){
    try{
      const fps = 30;
      const cs = canvas.captureStream ? canvas.captureStream(fps) : null;
      if (!cs) return;
      const mime = pickBestMime();
      mediaRecorder = new MediaRecorder(cs, mime ? {mimeType:mime} : {});
      chunks = [];
      mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
      mediaRecorder.onstop = finalizeRecording;
      mediaRecorder.start();
      recording = true; recDot.style.display = 'block';
      recordTimer = setTimeout(()=>{ if(recording) stopRecording(); }, 30000);
    }catch(e){ console.error(e); }
  }
  function stopRecording(){
    try{
      if (recordTimer) clearTimeout(recordTimer);
      recordTimer = null;
      if (mediaRecorder && recording) mediaRecorder.stop();
    }catch(e){ console.error(e); }
  }
  function finalizeRecording(){
    recording = false; recDot.style.display = 'none';
    const blob = new Blob(chunks, { type: chunks[0]?.type || 'video/webm' });
    const url = URL.createObjectURL(blob);
    const ext = blob.type.includes('mp4') ? 'mp4' : 'webm';
    const a = document.createElement('a'); a.href = url; a.download = `livefx_${Date.now()}.${ext}`; a.target = '_blank'; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 60000);
  }

  // Effects (same realism core, no on-screen text)
  const lerp=(a,b,t)=>a+(b-a)*t, rand=(a=0,b=1)=>Math.random()*(b-a)+a;
  function hexToRgb(hex){ const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); if(!m) return {r:127,g:197,b:255}; return {r:parseInt(m[1],16),g:parseInt(m[2],16),b:parseInt(m[3],16)}; }
  function makeNoise(seed=1337){ let s=seed; function xs(){s^=s<<13; s^=s>>17; s^=s<<5; return (s>>>0)/4294967295;}
    const g=new Array(512).fill(0).map(()=>({x:xs()*2-1,y:xs()*2-1})); function fade(t){return t*t*t*(t*(t*6-15)+10);}
    return (x,y)=>{ const xi=Math.floor(x)&255, yi=Math.floor(y)&255; const xf=x-Math.floor(x), yf=y-Math.floor(y);
      const tl=g[(xi+(yi)*2)&511], tr=g[(xi+1+(yi)*2)&511], bl=g[(xi+(yi+1)*2)&511], br=g[(xi+1+(yi+1)*2)&511];
      const dot=(v,dx,dy)=>v.x*dx+v.y*dy; const u=fade(xf), v=fade(yf);
      const x1=lerp(dot(tl,xf,yf),dot(tr,xf-1,yf),u); const x2=lerp(dot(bl,xf,yf-1),dot(br,xf-1,yf-1),u); return lerp(x1,x2,v); };
  }
  const noise = makeNoise();

  let lastT=performance.now();
  function initEffect(){ particles.length=0; tuneEffect(true); }
  function tuneEffect(reset=false){
    const tint = hexToRgb(tintEl.value);
    const I = intensityEl.value/100, S = speedEl.value/100, Z = sizeEl.value/100;
    const ang = (+dirEl.value) * Math.PI/180, wind = { x: Math.cos(ang), y: Math.sin(ang) };
    const target = { rain:Math.floor((w*h)/9000*(0.2+I*1.2)), snow:Math.floor((w*h)/16000*(0.2+I*1.3)), fire:Math.floor(120*(0.3+I*1.7)), wind:Math.floor(70*(0.3+I*2.0)) }[effect]||0;
    if (reset || particles.length===0){ particles.length=0; for(let i=0;i<target;i++) particles.push(makeParticle(effect,wind,S,Z,tint)); }
    else if (particles.length<target){ for(let i=particles.length;i<target;i++) particles.push(makeParticle(effect,wind,S,Z,tint)); }
    else if (particles.length>target){ particles.length=target; }
    for (const p of particles){ p.wind=wind; p.speedScale=S; p.sizeScale=Z; p.tint=tint; }
  }

  function makeParticle(type, wind, S, Z, tint){
    switch(type){
      case 'rain': return {type,x:Math.random()*w,y:Math.random()*h,len:(8+20*Z)*dpr,thick:(0.6+0.9*Z)*dpr,vel:(6+10*S)*dpr,drift:(wind.x*2+(Math.random()-0.5))*dpr,wind,speedScale:S,sizeScale:Z,tint};
      case 'snow': { const depth=0.3+Math.random()*0.7; return {type,x:Math.random()*w,y:Math.random()*h,r:(0.8+2.0*Z*depth)*dpr,depth,sway:Math.random()*Math.PI*2,spin:(Math.random()-.5)*0.04,wind,speedScale:S,sizeScale:Z,tint}; }
      case 'fire': return makeFireParticle(w,h,S,Z,tint);
      case 'wind': return {type,x:(Math.random()*2-1)*w,y:Math.random()*h,len:(8+12*Z)*dpr,rot:Math.random()*Math.PI*2,rotSpd:(Math.random()-.5)*0.06,vx:(2+3*S)*dpr*wind.x,vy:(0.5+1.5*S)*dpr*wind.y,tint,wind,speedScale:S,sizeScale:Z};
      default: return {};
    }
  }
  function makeFireParticle(w,h,S,Z,tint){
    return {type:'fire',x:w*0.5+(Math.random()*2-1)*w*0.12,y:h-Math.random()*20*dpr,vx:(Math.random()*0.8-0.4)*dpr,vy:-(1.0+2.2*S)*dpr,life:0.8+Math.random()*0.8,age:0,r:(2.0+3.0*Z)*dpr,ember:Math.random()<0.15?1:0,tint};
  }

  function tick(t){
    if (!running) return;
    requestAnimationFrame(tick);
    if (!video.videoWidth) return;
    resize();
    if (blurEl.checked){ ctx.fillStyle='rgba(0,0,0,0.08)'; ctx.fillRect(0,0,w,h); } else ctx.clearRect(0,0,w,h);
    drawVideoCover(ctx, video, w, h);
    switch(effect){
      case 'rain': drawRain(t); break;
      case 'snow': drawSnow(t); break;
      case 'fire': drawFire(t); break;
      case 'wind': drawWind(t); break;
    }
    lastT = t;
  }

  function drawRain(t){
    const rgb = hexToRgb(tintEl.value);
    ctx.lineCap='round';
    for (const p of particles){
      const n = noise(p.x*0.003, (p.y+t*0.0015)*0.003);
      const vx = p.drift + p.wind.x*1.4 + n*0.2;
      const vy = p.vel + p.wind.y*0.6;
      ctx.strokeStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},0.65)`;
      ctx.lineWidth = p.thick;
      ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x + vx*1.5, p.y + p.len); ctx.stroke();
      p.x += vx; p.y += vy;
      if (p.y > h - 2*dpr){ p.y = -20; p.x = Math.random()*w; }
      if (p.x < -20) p.x = w+20; if (p.x > w+20) p.x = -20;
    }
  }

  function drawSnow(t){
    const rgb = hexToRgb(tintEl.value);
    ctx.fillStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},0.95)`;
    for (const p of particles){
      p.sway = (p.sway||0) + (p.spin||0);
      const n = noise((p.x+t*0.0007)*0.004, (p.y-t*0.0005)*0.004);
      const swayX = Math.sin(p.sway)*0.4*dpr + n*0.8*dpr;
      const baseFall = ((0.4 + 1.0*(speedEl.value/100)))*dpr*(0.6+0.4*(1-(p.depth||0.8)));
      const windX = p.wind.x*1.6*dpr, windY = p.wind.y*0.8*dpr;
      p.x += swayX + windX; p.y += baseFall + windY;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.r||1.5*dpr, 0, Math.PI*2); ctx.fill();
      if (p.y > h+5) { p.y = -5; p.x = Math.random()*w; }
      if (p.x < -5) p.x = w+5; if (p.x > w+5) p.x = -5;
    }
  }

  function drawFire(t){
    const S = speedEl.value/100, Z = sizeEl.value/100;
    for (let i=0;i<Math.floor(6*(0.3+S*1.7));i++) particles.push(makeFireParticle(w,h,S,Z,hexToRgb(tintEl.value)));
    for (let i=particles.length-1;i>=0;i--){
      const p = particles[i]; if (p.type!=='fire') continue;
      p.age += 0.016;
      const n = noise(p.x*0.01, (p.y+t*0.0015)*0.01);
      p.x += (p.vx||0) + n*0.8*dpr; p.y += (p.vy||0) - p.age*0.35*dpr;
      const life = Math.max(0, 1 - p.age/(p.life||1)); const r = (p.r||2*dpr)*(0.6+life);
      const hot = {r:255, g: Math.floor(120 + 100*life), b:0}; const tint=p.tint||{r:255,g:140,b:0};
      const cr=Math.floor(0.75*hot.r + 0.25*tint.r), cg=Math.floor(0.85*hot.g + 0.15*tint.g), cb=Math.floor(0.95*hot.b + 0.05*tint.b);
      const grd = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,r);
      grd.addColorStop(0,`rgba(${cr},${cg},${cb},${0.85*life})`); grd.addColorStop(1,`rgba(${cr},${cg},${cb},0)`);
      ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill();
      if (life<=0 || p.y < -20) particles.splice(i,1);
    }
  }

  function drawWind(t){
    const rgb = hexToRgb(tintEl.value);
    ctx.strokeStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},0.55)`; ctx.lineWidth = 1.2*dpr;
    for (const p of particles){
      const gust = noise((p.y+t*0.0012)*0.01, (p.x-t*0.001)*0.01)*1.2;
      const vx = (p.vx||0) + gust*0.8, vy = (p.vy||0) + gust*0.2;
      const x2 = p.x + Math.cos(p.rot||0)*(p.len||10), y2 = p.y + Math.sin(p.rot||0)*(p.len||10);
      ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(x2, y2); ctx.stroke();
      p.x += vx; p.y += vy; p.rot = (p.rot||0) + (p.rotSpd||0);
      if (p.x > w+30){ p.x = -30; p.y = Math.random()*h; }
      if (p.x < -30){ p.x = w+30; p.y = Math.random()*h; }
      if (p.y > h+30){ p.y = -30; p.x = Math.random()*w; }
      if (p.y < -30){ p.y = h+30; p.x = Math.random()*w; }
    }
  }

  // helpers reused above
  function hexToRgb(hex){ const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); if(!m) return {r:127,g:197,b:255}; return {r:parseInt(m[1],16),g:parseInt(m[2],16),b:parseInt(m[3],16)}; }

  // Kick to full screen on first interaction (optional, no text)
  document.addEventListener('touchend',()=>{ const de=document.documentElement; if (de.requestFullscreen) { try{de.requestFullscreen();}catch{}} },{once:true});
})();
</script>
</body>
</html>
